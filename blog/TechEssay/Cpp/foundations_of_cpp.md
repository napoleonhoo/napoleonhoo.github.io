# 《Foundations of C++》阅读笔记

这是一篇“C++之父”Bjarne Stroustrup在ETAPS（European Joint Conferences on Theory and Practice of Software）的演讲稿。希望阅读原文的，可以参见作者的个人网站。[链接](https://www.stroustrup.com/ETAPS-corrected-draft.pdf)

本文并非是对C++的教程，而是作者通过对C++中几个重要的特性来告诉大家C++的设计哲学。由于其本人也任职于ISO C++标准委员会，也是处理C++语言标准扩展小组（Evolution Working Group）的主席，他的一些话，即是他自己的想法，也很可能会成为C++将来的发展标志。

另外，这篇文章成于2012年，那个时候C++11刚出来没多久，因此本文中所讲的一些内容是以C++11特性为主的，并且作者认为的一些想法、困难和挑战已经是C++20的标准了。

话不多说，以下便是对这篇文章的一些摘录、讲解和心得。

## Ideals

C++的目标就是来帮助经典的系统编程任务。对资源有限（resource-constrained）的和至关重要（mission-critical）的基础设施应用，它支持使用轻量级的抽象。它通过以下两点，达成让编程者使用最高级别可行的抽象：
- 简单和直接的对硬件的映射
- 零开销（zero-overhead）的抽象机制

所说的“轻量级抽象”，意思是指抽象所产生的空间、时间开销不会超过一个程序员精心手写的代码。

## 内存和对象

C++直接映射到硬件。

对于基本类型，（如`char`、`int`、`double`）直接映射到内存实体上（如字节、字）。大部分处理器提供的算数和逻辑操作可以直接用在其上。指针、数组、引用可以直接反应硬件的地址。在C++程序员和硬件之间，没有“抽象”、“虚拟”、数学模型之类的东西。

内存呗看作是一系列的字节。一个对象被分配到内存的一个地方（一系列的字节），值就被放在这里。一系列的对象一般被放在数组中，通过持有其地址的指针来访问。通常地，操作一系列对象的代码，需要一个指向数组起始位置的指针，和一个指向结束位置后面一位的指针。

Named object静态地分配或者说分配在栈上。只有当我们明确地分配一个对象在自由存储区（堆）上，我们才会引入内存开销。相应地，基础的继承只会简单地将基类和派生类的成员拼接到一起。

只有当我们用`virtual`函数时，我们需要添加支持的数据结构，并且这也只是函数表。

![`virutal`函数的情况](foundations_of_cpp_fig1.svg)

一般地，C++的实现遵循零开销原则：What you don't use, you don't pay for.（你不使用的，不需要为此付出代价。）进一步地，What you do use, you couldn't hand code any better.（你需要用的，你不会手写地更好。）

注意到并不是所有的语言都提供如此简单的对硬件的映射，并且支持这些简单的规则。比如说“某些纯面向对象的语言”。 *注：文中并没有明确说是那个语言。* 这种对内存非直接的访问一般会对cache使用造成问题，并且限制了ROM的能力。

通过构造函数，内存变成一个持有某种类型值的对象。析构函数是这个过程的逆操作：析构函数执行之后，对象就不再存在了，它原来的地方就又重新是内存了。

## 编译期计算

在一些时候，我们更希望一些计算在编译期执行。原因可能是：

- 效率：比如一些对象、数组大小和表数据的计算。
- 类型安全：计算一个类型。
- 简单地并行：对常量类型，不会有竞争情况（race condition）。

`constexpr`关键词是C++的方法来指定编译期赋值，指定一个函数在编译期执行。

在一些关键的嵌入式系统应用中、底层代码、高端的数学应用中，各种各样的用户指定的编译期计算是很重要的。

## 错误处理

`try`、`catch`、`throw`

对硬实时编程（并且只有这种情况），这种错误处理的方法可以换成更底层的错误处理风格。原因是对于异常传播并没有一个很好的实时性保证。

## 容器

标准库的`vector`、`map`、`set`、`list`使用了下述的技术：
- 类：分开不同的接口
- 构造函数：建立不变量，包括获取资源
- 析构函数：释放资源
- 模版：参数化类型、有类型的算法
- 源语言特征到指定其含义的用户定义代码的映射，如`[]`取下标，`for`循环，构造函数、析构函数使用`new`、`delte`在自由区域分配、回收内存，`{}`初始化列表
- 使用半开序列，如`[begin(): end()]`来定义for循环和一般的算法
- 使用标准库函数来简化特化与实现

更重要地，从内存到对象容器的抽象，除了必要的内存管理、初始化和错误处理外，不会带来额外开销。

注意到：
- `Vector`中除了两个命名成员（指针、大小）以外，没有其他的数据存储了。
- 不要求元素类型作为继承体系中的一部分。当使用到这个模版的时候才需要。
- 它的函数不要求是动态地决定（`virtual`）。简单的操作，如`size()`、`[]`一般是内联的。

换句话说，这些特性和技术（抽象机制）是轻量级的，目标是在高要求的系统编程和基础设施实现任务中。

允许程序员来定义一个更大的、多样的抽象集合，但不失去对高要求系统编程任务的灵活性和效率。

## 拷贝和移动

如果一个类，同时有移动和拷贝函数，对右值来讲一般使用移动函数，对左值来讲一般使用拷贝函数。

## RAII

资源就是一个程序从系统的其他部分获取的东西，并且使用完一定要显式或隐式地将其释放回它的所有者。没被使用的且没被释放的资源就叫泄漏。内存就是资源的一个重要例子。

`vector`使用的构造函数、析构函数技术可以泛化到任何一个资源的使用，并且移动技术可以处理不同scope之间的所有权转移。核心思路是资源一直被一个局部对象所拥有。这样一个局部对象有时候被称为资源句柄（handle）、所有者（owner），或者简单称为接口（interface），比如`vector`就是对其中元素的一个接口。句柄的构造函数获取一种资源，然后在析构函数中释放。

在资源的释放这种考虑下，这个RAII的思路比Java里面的“finally”更好。

使用这种类型的句柄，多个资源的释放顺序和获取的顺序恰好相反。

内存并不是唯一的资源，还有如文件、锁之类的，所以只是简单的加一个垃圾回收（garbage collection）并不管用。

## 类继承

对象的布局是最小的和明显的。虚拟函数调用的机制是最小的、明显的，并且常量时间运行。导致的紧凑、速度和可预测性对许多实时化应用很重要。

C++不提供一个全局性的基类。作者认为这样一个类是不必要的实现导向的作品，会产生不可避免的空间、时间开销。一个全局的“Object”基类会鼓励未指定的接口，会使得可以在编译器探测到的错误转移到运行时。一般地，其他语言使用共同基类，并且需要显式或隐式地使用类型转换来确定准确的派生类，C++使用参数化来代替。

## 算法

标准库算法，如`sort`、`find`，使用元素的半开区间的迭代器作为输入。

`auto`是一个很有用的简写，在泛型编程中很有用。

如果你喜欢简要地C风格的语法，你会发现`find`的实现很漂亮。如果不是的话，你仍然会喜欢`find`适用的数据结构范围之广，且对于特定的容器来讲，和自己写的代码相比，没有额外的开销。返回序列的结尾（end）就代表了没有找到，这是一个标准库的惯例。

通过将操作作为参数，算法一般会变得更有用。比如，`find_if`，让用户提供了一个标准。

`find_if`的最后一个参数可以是函数对象。函数对象的写作一般比较冗长，我们也使用lambda函数，来让语言帮我们写一个函数对象。函数对象（包括lambda）是非常高效的，因为它们一般都可以内联，并且携带信息。特别地，简单的函数对象一般会比对函数的间接调用更高效。

模版是C++泛型编程的语言技术基础。类似地，类继承是C++面向对象编程的语言技术基础。这俩编程风格（范式）不是脱节的。相反地，它们注定要一起使用的。如`vector<Shape*>`是运行时多态类型的容器。

## 类型函数



## 英语学习

1. incidental：伴随而来的、非有意的、附带发生的
2. caveat：警告、附加说明
3. in excess of：超过
4. archetypical：典型的
5. devise：设计、发明、想出
6. underspecified：未指定的
7. overly：过度地、过于、十分、很
8. render：提供、给予
9. terse：简单生硬地、简要地